version: 2
jobs:
  build:
    working_directory: /usr/src/app
    docker:
      - image: quay.io/opentargets/mrtarget_build_base:ep-circleci
    environment:
      CTTV_MINIMAL: True
    steps:
      - checkout
      - restore_cache:
         keys: 
          # Find a cache corresponding to this specific requirements.txt checksum
          # when this file is changed, this key will fail
          - mrt-py27-a-{{ .Branch }}-{{ checksum "requirements.txt" }}
          # Find a cache corresponding to any build in this branch, regardless of package.json
          # checksum.  The most recent one will be used.
          - mrt-py27-a-{{ .Branch }}
      - run:
          name: Install requirements.txt
          command: |
            pip install -U -r requirements.txt
            pip uninstall -y requests
            pip install requests
      - save_cache:
          key: mrt-py27-a-{{ .Branch }}-{{ checksum "requirements.txt" }}
          paths:
            - "/usr/local/lib/python2.7/site-packages"
      - run:
          name: Dry run to check imports
          command: |
            mrtarget --dry-run
  push_containers:
    working_directory: /usr/src/app
    docker:
      - image: quay.io/opentargets/mrtarget_build_base:ep-circleci
    steps:
      - checkout
      - setup_remote_docker:
          reusable: true    # this allows caching, but may become a premium feature
          exclusive: true
      - run:
          name: Build Docker image
          command: |
            docker build -t circle-${CIRCLE_SHA1} .
      - run:
          name: Push to GCR
          command: |
            docker login -u _json_key -p "${GCR_JSON_KEY_FILE}" https://eu.gcr.io
            ## branch tag and push
            docker tag circle-${CIRCLE_SHA1} ${GCR_REPO}:${CIRCLE_BRANCH}
            docker push ${GCR_REPO}:${CIRCLE_BRANCH}
            ## SHA commit push
            docker tag ${GCR_REPO}:${CIRCLE_BRANCH} ${GCR_REPO}:circle-${CIRCLE_SHA1}
            docker push ${GCR_REPO}:circle-${CIRCLE_SHA1}
            ## push latest if master
            if [ "$CIRCLE_BRANCH" = "master" ]
              then
                docker tag ${GCR_REPO}:${CIRCLE_BRANCH} ${GCR_REPO}:latest
                docker push ${GCR_REPO}:latest
            fi
      - run:
          name: Push to Quay
          command: |
            docker login -u="opentargets+quaybot" -p="${QUAYBOT_PASSWORD}" quay.io
            ## branch tag and push
            docker tag circle-${CIRCLE_SHA1} ${QUAY_REPO}:${CIRCLE_BRANCH}
            docker push ${QUAY_REPO}:${CIRCLE_BRANCH}
            ## sha commit push
            docker tag ${QUAY_REPO}:${CIRCLE_BRANCH} ${QUAY_REPO}:circle-${CIRCLE_SHA1}
            docker push ${QUAY_REPO}:circle-${CIRCLE_SHA1}
            ## push latest if master
            if [ "$CIRCLE_BRANCH" = "master" ] 
              then
                docker tag ${QUAY_REPO}:${CIRCLE_BRANCH} ${QUAY_REPO}:latest
                docker push ${QUAY_REPO}:latest
            fi
            

# using a workflow allows better separation of steps and rerunning them

workflows:
  version: 2
  build_and_push:
    jobs:
      - build
      - push_containers:
          requires:
            - build


# Ideally, we would fan these out, but we would need to persist the docker image
# we built somewhere or build it for each step. It seems that caching of docker
# images would be kept as premium feature.

# also we need to pay for > 1 container at the same time for it to actually run
# faster.



